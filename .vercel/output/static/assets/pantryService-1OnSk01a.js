import{s}from"./index-o6bm3qdW.js";const $=[[/^(.+)es$/i,"$1"],[/^(.+[aeiou])s$/i,"$1"],[/^(.+[zñ])es$/i,"$1"],[/^(.+)ces$/i,"$1z"],[/^(.+)les$/i,"$1l"],[/^(.+)s$/i,"$1"]],_=[[/^(.+[aeiou])$/i,"$1s"],[/^(.+[zñ])$/i,"$1es"],[/^(.+[l])$/i,"$1es"],[/^(.+[r])$/i,"$1es"],[/^(.+)$/i,"$1s"]],w="ingredients",E=async e=>{const{data:o,error:r}=await s.from(w).select("*").ilike("name",e.trim()).maybeSingle();return r?(console.error("Error finding ingredient:",r),null):o},I=async e=>{const{data:{user:o}}=await s.auth.getUser();if(!o)throw new Error("Usuario no autenticado");const{data:r,error:t}=await s.from(w).insert({name:e.trim()}).select().single();if(t)throw console.error("Error creating ingredient:",t),t;return r};function k(e){for(const[o,r]of $)if(o.test(e))return e.replace(o,r);return e}function U(e){for(const[o,r]of _)if(o.test(e))return e.replace(o,r);return e}function p(e,o=1){const r=e.trim();if(!r)return"";const n=k(r.toLowerCase()).split(" ").map(i=>i.charAt(0).toUpperCase()+i.slice(1)).join(" ");return o===1?n:U(n)}const q=async(e,o=1)=>{const r=p(e,o);if(!r)throw new Error("El nombre del ingrediente no puede estar vacío.");console.log(`Buscando o creando ingrediente normalizado: "${r}" (original: "${e}")`);const t=await E(r);if(t)return console.log(`Ingrediente encontrado: ${t.id}`),t;console.log(`Creando nuevo ingrediente: "${r}"`);const n=await I(r);return console.log(`Ingrediente creado: ${n.id}`),n},d=new Map;let m=!1;async function h(){if(m)return;console.debug("[categoryInference] Loading keywords from DB...");const{data:e,error:o}=await s.from("category_keywords").select("keyword, category_id, priority");if(o){console.error("Error loading keywords:",o);return}d.clear();for(const r of e){const t=r.keyword.toLowerCase(),n={categoryId:r.category_id,priority:r.priority};d.has(t)?d.get(t).push(n):d.set(t,[n])}m=!0,console.debug(`[categoryInference] Loaded ${d.size} unique keywords.`)}async function x(e){if(!e||!m&&(await h(),!m))return null;const r=e.toLowerCase().replace(/(es|s)$/,"").split(/\s+/).filter(Boolean),t=new Map;for(const u of r){const c=d.get(u);if(c)for(const f of c){const y=t.get(f.categoryId)||{score:0,maxPriority:-1};y.score+=f.priority+1,y.maxPriority=Math.max(y.maxPriority,f.priority),t.set(f.categoryId,y)}}let n=null,i=0,a=-1,l=!1;for(const[u,c]of t.entries())c.score>i?(i=c.score,n=u,a=c.maxPriority,l=!1):c.score===i&&i>0&&(c.maxPriority>a?(n=u,a=c.maxPriority,l=!1):c.maxPriority===a&&(l=!0));return!l&&n&&i>=1?(console.debug(`[categoryInference] Inferred category ${n} for "${e}" (Score: ${i})`),n):(console.debug(`[categoryInference] Could not infer category for "${e}" (Tie: ${l}, Max Score: ${i})`),null)}h();const P=async()=>{try{const{data:{user:e},error:o}=await s.auth.getUser();if(o)throw console.error("Error getting auth user:",o),new Error("Error de autenticación");if(!e)throw console.error("No user found in session"),new Error("Usuario no autenticado");console.log("Auth check passed. User ID:",e.id);const{error:r}=await s.from("pantry_items").select("id").limit(1);if(r)throw console.error("Error checking pantry_items table:",r),new Error("Error accediendo a la tabla pantry_items");console.log("Table check passed. Fetching items...");const{data:t,error:n}=await s.from("pantry_items").select("*, ingredients(*), categories(*)").eq("user_id",e.id).order("created_at",{ascending:!1});if(n)throw console.error("Error fetching pantry items:",n),n;console.log(`Successfully fetched ${(t==null?void 0:t.length)??0} items`);const i=(t||[]).map(a=>({...a,ingredient:a.ingredients?{name:p(a.ingredients.name,a.quantity??1)}:null,category:a.categories,ingredients:void 0,categories:void 0}));return console.log("Mapped pantry items:",i),i}catch(e){throw console.error("getPantryItems failed:",e),e}},S=async e=>{const{data:{user:o}}=await s.auth.getUser();if(!o)throw new Error("Usuario no autenticado");console.log("Adding pantry item:",e);const r=await q(e.ingredient_name,e.quantity??1);if(!r)throw new Error(`No se pudo crear/encontrar el ingrediente "${e.ingredient_name}"`);let t=e.category_id;if(!t&&(r!=null&&r.name))try{console.log(`Attempting to infer category for: "${r.name}"`);const g=await x(r.name);g?(t=g,console.log(`Successfully inferred category ${t} for "${r.name}"`)):console.log(`Could not infer category for "${r.name}", leaving as null.`)}catch(g){console.error("Error during category inference:",g)}const n={user_id:o.id,ingredient_id:r.id,quantity:e.quantity??1,unit:e.unit,expiry_date:e.expiry_date,category_id:t,price:e.price,notes:e.notes,min_stock:e.min_stock,target_stock:e.target_stock,tags:e.tags},{data:i,error:a}=await s.from("pantry_items").insert(n).select("*, ingredients(*), categories(*)").single();if(a)throw console.error("Error adding pantry item:",a),a;console.log("Raw pantry item added:",i);const l={...i,ingredient:i.ingredients?{name:p(i.ingredients.name,i.quantity??1)}:null,category:i.categories,ingredients:void 0,categories:void 0};return console.log("Mapped pantry item:",l),l},L=async(e,o)=>{const{data:{user:r}}=await s.auth.getUser();if(!r)throw new Error("Usuario no autenticado");console.log(`Updating pantry item ${e} for user ${r.id}:`,o);const{data:t,error:n}=await s.from("pantry_items").update({quantity:o.quantity,unit:o.unit,expiry_date:o.expiry_date,category_id:o.category_id,location:o.location,price:o.price,notes:o.notes,min_stock:o.min_stock,target_stock:o.target_stock,updated_at:new Date().toISOString(),tags:o.tags}).eq("id",e).eq("user_id",r.id).select("*, ingredients(*), categories(*)").single();if(n)throw console.error("Error updating pantry item:",n),n;if(!t)throw new Error("Item no encontrado o permiso denegado para actualizar.");console.log("Raw pantry item updated:",t);const i={...t,ingredient:t.ingredients?{name:p(t.ingredients.name,t.quantity??1)}:null,category:t.categories,ingredients:void 0,categories:void 0};return console.log("Mapped updated item:",i),i},b=async e=>{const{data:{user:o}}=await s.auth.getUser();if(!o)throw new Error("Usuario no autenticado");console.log(`Deleting pantry item ${e} for user ${o.id}`);const{error:r}=await s.from("pantry_items").delete().eq("id",e).eq("user_id",o.id);if(r)throw console.error("Error deleting pantry item:",r),r;console.log("Pantry item deleted successfully:",e)},M=async()=>{const{data:{user:e}}=await s.auth.getUser();console.log("Fetching categories...");const o=e?`is_default.eq.true,user_id.eq.${e.id}`:"is_default.eq.true",{data:r,error:t}=await s.from("categories").select("*").or(o).order("is_default",{ascending:!1}).order("order",{ascending:!0});if(t)throw console.error("Error fetching categories:",t),t;return console.log(`Categories fetched: ${(r==null?void 0:r.length)??0}`),r||[]},v=async e=>{if(!e||e.length===0){console.log("No item IDs provided for deletion.");return}const{data:{user:o}}=await s.auth.getUser();if(!o)throw new Error("Usuario no autenticado");console.log(`Deleting ${e.length} pantry items for user ${o.id}:`,e);const{error:r}=await s.from("pantry_items").delete().in("id",e).eq("user_id",o.id);if(r)throw console.error("Error deleting multiple pantry items:",r),r;console.log("Multiple pantry items deleted successfully:",e)};export{S as a,M as b,v as c,b as d,P as g,L as u};
